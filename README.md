# Sample IPC

## Сборка проекта
1. Создать папку для сборки проекта
```
mkdir build
```
2. Перейти в папку `build`
```
cd build
```
3. Сконфигурировать сборку
```
cmake ..
```
4. Собрать исполняемые файлы
```
make
```

## Общее описание
Данный репозиторий содержит исходный код к трем программам, которые демонстрируют межпроцессорное взаимодействие
в неблокирующем режиме.

Каждая программа имеет принимает входные параметры:
`COUNT_OF_MESSAGE` - целое число больше нуля, отвечает за количество сообщений.
`SIZE_OF_MESSAGE`  - целое число больше нуля, отвечает за размер сообщения сообщения.

Запускаемая программа является главным процессом. В его задачи входит инициализация и деинициализация ресурсов
для межпроцессорного взаимодействия. После инициализации ресурсов он создает два дочерних процесса с помощью fork + exec.
Первый созданный процесс принимает сообщения от второго процесса. Главный процесс ждет завершения дочерних, после очищает
выделенные ресурсы.

## Shared memory via signal

В `shm_signal` IPC реализовано через доступ к общей памяти. Синхранизация реализована через отправку сигналов и ожидание их через файловый дискриптор.
1. Отправитель записывает сообщение в общую память.
2. Отправитель посылает сигнал получателю.
3. Получатель принимает сигнала (пробуждается из poll).
4. Получатель вычитывает сигнал из "signalfd".
5. Получатель вычитывает данные из общей памяти.
6. Отправляет сигнал отправителю.
7. Отправитиль принимает сигнала (пробуждается из poll).
8. Отправитиль вычитывает сигнал из "signalfd".
9. Шаг №1.


### Запуск
```
./signal/shm_signal -c COUNT_OF_MESSAGE -s SIZE_OF_MESSAGE
```
### Пример
```
./signal/shm_signal -c 200 -s 200
MAIN[2781]: pid c:0, s:2782
MAIN[2781]: pid c:2783, s:2782
WRITER[2783]: START_TIME: s: 20395,  n:568939575
READER[2782]: START_TIME: s: 20395,  n:568899307
WRITER[2783]: END_TIME: s: 20395,  n:584931399
READER[2782]: END_TIME: s: 20395,  n:584942415
WRITER[2783]: DURATION: sec: 0, nanosec: 15991824
READER[2782]: DURATION: sec: 0, nanosec: 16043108
READER[2782]: Message per seconds: 12466.412109
WRITER[2783]: Message per seconds: 12506.390625
```

## Shared memory via eventfd

В `shm_event` IPC реализовано через доступ к общей памяти. Синхранизация реализована через eventfd.
eventfd хранит в себе счетчик типа uint64_t от 0 до 0xfffffffffffffffe.

1. Отправитель записывает сообщение в общую память.
2. Записывает в счетчик 0xfffffffffffffffe.
3. Получатель пробуждается из poll.
4. Получатель вычитывает данные из общей памяти.
5. Получатель сбрасывает счетчик до 0.
7. Отправитиль пробуждается из poll.
8. Шаг №1.

### Запуск
```
./event/shm_event -c COUNT_OF_MESSAGE -s SIZE_OF_MESSAGE
```

### Пример
```
./event/shm_event -c 200 -s 200
READER[2785]: Start reader
WRITER[2786]: Start writer
WRITER[2786]: START_TIME: s: 20566,  n:985684440
READER[2785]: START_TIME: s: 20566,  n:985400903
WRITER[2786]: END_TIME: s: 20566,  n:78683
WRITER[2786]: DURATION: sec: 0, nanosec: 14394243
READER[2785]: END_TIME: s: 20566,  n:84083
WRITER[2786]: Message per seconds: 13894.443359
READER[2785]: DURATION: sec: 0, nanosec: 14683180
READER[2785]: Message per seconds: 13621.028320
```

## Domain datagram socket

В `socket` IPC реализовано через локальные сокеты.

1. Отправитель отпраляет сообщение с помошью `sendmsg`.
2. Получатель пробуждается из poll.
3. Получатель читывает данные с помошью `recvmsg`.
4. Отправитиль пробуждается из poll.
5. Шаг №1.

### Запуск
```
./socket/socket -c COUNT_OF_MESSAGE -s SIZE_OF_MESSAGE
```
### Пример
```
./socket/socket -c 200 -s 200
WRITER[2789]: START_TIME: s: 20643,  n:543479975
READER[2788]: START_TIME: s: 20643,  n:543863538
WRITER[2789]: END_TIME: s: 20643,  n:544044710
READER[2788]: END_TIME: s: 20643,  n:544060081
WRITER[2789]: DURATION: sec: 0, nanosec: 564735
READER[2788]: DURATION: sec: 0, nanosec: 196543
WRITER[2789]: Message per seconds: 354148.406250
READER[2788]: Message per seconds: 1017589.062500
```